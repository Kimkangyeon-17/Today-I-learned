# Today I Learned

## 목표 : 카운팅 정렬과 탐욕 알고리즘에 대해 알아보고자 합니다.


## 1. 카운팅 정렬 (Counting Sort)

### 1-1. 카운팅 정렬이란?
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여 선형 시간에 정렬하는 효율적인 방식
- **제한 사항**
    - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
    - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
- **시간 복잡도**: O(n+k) (n은 리스트 길이, k는 정수의 최댓값)
- **공간 복잡도**: O(k)

### 1-2. 카운팅 정렬 과정 예시

**초기 데이터:** `Data = [0, 4, 1, 3, 1, 2, 4, 1]`

#### 1단계: 각 항목의 발생 횟수 계산

| index | 0 | 1 | 2 | 3 | 4 |
|-------|---|---|---|---|---|
| counts (초기) | 0 | 0 | 0 | 0 | 0 |
| counts (계산 후) | 1 | 3 | 1 | 1 | 2 |

#### 2단계: 누적 합 계산 (각 원소가 정렬된 배열에서 들어갈 위치 정보)

| index | 0 | 1 | 2 | 3 | 4 |
|-------|---|---|---|---|---|
| counts (누적 전) | 1 | 3 | 1 | 1 | 2 |
| counts (누적 후) | 1 | 4 | 5 | 6 | 8 |

#### 3단계: 뒤에서부터 정렬된 배열에 배치

| 단계 | j | Data[j] | counts 상태 | temp 배열 |
|------|---|---------|-------------|-----------|
| 초기 | - | - | [1, 4, 5, 6, 8] | [_, _, _, _, _, _, _, _] |
| 1 | 7 | 1 | [1, **3**, 5, 6, 8] | [_, _, _, **1**, _, _, _, _] |
| 2 | 6 | 4 | [1, 3, 5, 6, **7**] | [_, _, _, 1, _, _, _, **4**] |
| 3 | 5 | 2 | [1, 3, **4**, 6, 7] | [_, _, _, 1, **2**, _, _, 4] |
| 4 | 4 | 1 | [1, **2**, 4, 6, 7] | [_, _, **1**, 1, 2, _, _, 4] |
| 5 | 3 | 3 | [1, 2, 4, **5**, 7] | [_, _, 1, 1, 2, **3**, _, 4] |
| 6 | 2 | 1 | [1, **1**, 4, 5, 7] | [_, **1**, 1, 1, 2, 3, _, 4] |
| 7 | 1 | 4 | [1, 1, 4, 5, **6**] | [_, 1, 1, 1, 2, 3, **4**, 4] |
| 8 | 0 | 0 | [**0**, 1, 4, 5, 6] | [**0**, 1, 1, 1, 2, 3, 4, 4] |

**최종 정렬 결과:** `temp = [0, 1, 1, 1, 2, 3, 4, 4]`

### 1-3. 코드 구현

```python
def counting_sort(Data, Temp, k):
    """
    Data [] -- 입력 배열(원소는 0 이상 k 이하 정수)
    Temp [] -- 정렬된 배열
    k -- 입력 배열의 최댓값
    """
    counts = [0] * (k+1)

    # 1단계: Data[i] 발생 횟수 기록
    for i in range(len(Data)):
        counts[Data[i]] += 1

    # 2단계: counts 값 조정(누적 합)
    for i in range(1, k+1):
        counts[i] += counts[i-1]

    # 3단계: 뒤에서부터 정렬된 배열에 배치
    for i in range(len(Data)-1, -1, -1):
        counts[Data[i]] -= 1
        Temp[counts[Data[i]]] = Data[i]
```

### 1-4. 동작 원리 설명
- **1단계**: 각 숫자가 몇 번 나타나는지 센다
- **2단계**: 누적 합을 구해서 각 숫자가 정렬된 배열에서 어느 위치까지 차지할지 결정
- **3단계**: 원본 배열을 뒤에서부터 읽으면서 정렬된 위치에 배치 (안정 정렬을 위해)

**핵심**: `counts[Data[i]]`는 `Data[i]` 값이 정렬된 배열에서 들어갈 **다음 위치**를 나타냅니다.

---

## 2. 탐욕 알고리즘 (Greedy Algorithm)

### 2-1. 탐욕 알고리즘이란?
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 방식

### 2-2. 탐욕 알고리즘의 특징
- **장점**: 구현이 간단하고 빠른 실행 속도
- **단점**: 최적해를 구하는 데 사용되는 근시안적인 방법으로, 각 선택의 시점에서 이루어지는 결정은 지역적으로 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없음
- 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근임

### 2-3. 탐욕 알고리즘 과정
1. **해 선택**: 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합(Solution Set)에 추가한다.

2. **실행 가능성 검사**: 새로운 부분 해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.

3. **해 검사**: 새로운 부분 해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1)의 해 선택부터 다시 시작한다.

### 2-4. Baby-gin을 통한 탐욕 알고리즘 이해

#### Baby-gin이란?
- 6자리 숫자에서 3자리씩 끊어서 다음 조건을 만족하는 게임
  - **Triplet**: 같은 숫자 3개 (예: 444)
  - **Run**: 연속된 숫자 3개 (예: 123, 456)
- 6자리 숫자가 모두 triplet과 run으로 구성되면 Baby-gin

#### 숫자에서 각 자릿수 추출하기
```python
num = 456789
c = [0] * 10  # 0~9 각 숫자의 개수를 저장할 배열

# 6자리 수로부터 각 자리 수를 추출하여 개수를 누적
for i in range(6):
    c[num % 10] += 1
    num //= 10

# 결과: c = [0, 0, 0, 0, 1, 1, 1, 1, 1, 1]
# 각 인덱스는 해당 숫자의 개수를 의미 (4,5,6,7,8,9가 각각 1개씩)
```

#### 탐욕 알고리즘을 활용한 Baby-gin 판별
```python
def baby_gin_greedy(cards):
    """
    탐욕 알고리즘으로 Baby-gin 판별
    """
    c = [0] * 10
    
    # 각 숫자의 개수 계산
    for card in cards:
        c[card] += 1
    
    i = 0
    tri = run = 0
    
    while i < 10:
        if c[i] >= 3:  # triplet 조사 후 데이터 삭제
            c[i] -= 3
            tri += 1
            continue
        if i < 8 and c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:  # run 조사 후 데이터 삭제
            c[i] -= 1
            c[i+1] -= 1
            c[i+2] -= 1
            run += 1
            continue
        i += 1
    
    if run + tri == 2:
        return True  # Baby gin
    else:
        return False  # Lose

# 예시 사용
cards1 = [6, 4, 4, 5, 4, 4]  # triplet(444) + run(456) = Baby gin
cards2 = [1, 2, 3, 1, 2, 3]  # triplet(111) + triplet(222) + run(333) 불가능
print(baby_gin_greedy(cards1))  # True
print(baby_gin_greedy(cards2))  # False
```

#### Baby-gin 문제에서 자주 실수하는 오답
**❌ 잘못된 접근**: 입력받은 숫자를 정렬한 후, 앞의 3자리씩 끊어서 run 및 triplet을 확인하는 방법
- 예시 1: `[6, 4, 4, 5, 4, 4]` → 정렬하여 `[4, 4, 4, 4, 5, 6]` → 쉽게 baby-gin 확인 가능
- 예시 2: `[1, 2, 3, 1, 2, 3]` → 정렬하면 `[1, 1, 2, 2, 3, 3]` → 오히려 baby-gin 확인에 실패

**이유**: 정렬 후 순서대로 확인하면 `[1, 2, 3]` + `[1, 2, 3]`의 조합을 놓칠 수 있음