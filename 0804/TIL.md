# Today I Learned

## 목표 : 정렬 알고리즘, 특히 버블 정렬에 대해 알아보고자 합니다.

### 1. 정렬이란?
- 2개 이상의 자료를 키(특정 기준)에 의해 작은 값부터 큰 값, 혹은 그 반대 순서로 재배열하는 알고리즘입니다.

- **정렬 알고리즘의 종류**
    - 버블 정렬(Bubble Sort)
    - 퀵 정렬(Quick Sort)
    - 카운팅 정렬(Counting Sort)
    - 삽입 정렬(Insertion Sort)
    - 선택 정렬(Selection Sort)
    - 병합 정렬(Merge Sort)

### 2. 버블 정렬(Bubble Sort)이란?
- 인접한 두 개의 원소를 비교하여 자리를 계속해서 교환하는 방식
- 간단하게 구현할 순 있지만, 시간 복잡도는 O(n²)으로 다른 정렬 알고리즘보다 속도가 느린 편입니다.

### 3. 버블 정렬 과정
    
1) 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막까지 자리를 이동
2) 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬됨

**예시 과정**
```
[8, 3, 1, 10, 5]

첫번째 순회:
(8, 3) → 3, 8, 1, 10, 5  (8과 3 비교 후 교환)
3, (8, 1) → 3, 1, 8, 10, 5  (8과 1 비교 후 교환)
3, 1, (8, 10) → 3, 1, 8, 10, 5  (8과 10 비교, 교환 안함)
3, 1, 8, (10, 5) → 3, 1, 8, 5, 10  (10과 5 비교 후 교환)

두번째 순회:
(3, 1) → 1, 3, 8, 5, 10  (3과 1 비교 후 교환)
1, 3, (8, 5) → 1, 3, 5, 8, 10  (8과 5 비교 후 교환)

세번째 순회:
1, 3, 5, 8, 10  (더 이상 교환 없음)
```

### 4. 구체적인 코드 구현
```python
def bubble_sort(arr):
    n = len(arr)
    
    # 모든 배열 요소를 순회
    for i in range(n):
        # 마지막 i개 요소는 이미 정렬됨
        for j in range(0, n - i - 1):
            # 인접한 요소 비교
            if arr[j] > arr[j + 1]:
                # 요소 교환
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    
    return arr

# 사용 예시
numbers = [8, 3, 1, 10, 5]
print("정렬 전:", numbers)
sorted_numbers = bubble_sort(numbers.copy())
print("정렬 후:", sorted_numbers)
```

### 5. 시간 복잡도 분석
- **최악의 경우**: O(n²) - 역순으로 정렬된 경우
- **최선의 경우**: O(n²) - 이미 정렬된 경우에도 모든 비교 수행
- **평균의 경우**: O(n²)
- **공간 복잡도**: O(1) - 추가 메모리 사용 없음

### 6. 장단점 비교

**장점:**
- 구현이 간단하고 이해하기 쉬움
- 제자리 정렬(In-place Sort): 추가 메모리 공간이 거의 필요하지 않음
- 작은 데이터셋에서는 충분히 사용 가능

**단점:**
- 시간 복잡도가 O(n²)로 높음
- 큰 데이터셋에는 매우 비효율적
- 다른 O(n²) 알고리즘(선택 정렬, 삽입 정렬)보다도 일반적으로 느림
- 실제 상용 시스템에서는 거의 사용되지 않음


### . 학습 정리
버블 정렬은 정렬 알고리즘의 기본 개념을 이해하기에 좋은 알고리즘입니다. 비록 실용성은 떨어지지만, 알고리즘의 시간 복잡도와 최적화 개념을 학습하는 데 매우 기본적인 알고리즘입니다. 